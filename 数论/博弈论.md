# Nim Game Ⅰ
## 题目描述
给定 `n` 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但**不能不拿**），最后**无法进行操作**的人视为失败。

如果两人都采用**最优策略**，先手是否必胜。

## 分析
由于两人都采取**最优策略**, 因此不考虑失误的情况, 则情况只分为 **初始状态先手必胜** 和 **初始状态先手必败** 两种

设第`i`堆石子的数量为`Ai`

首先假设只有一堆石子, 那么先手必胜, 因为先手可以拿走全部的石子

假设只有两堆石子, 数量为`1 3`, 可以先从第二堆中取走`2`颗石子, 剩下`1 1`, 在这种情况下对手只能拿走`1`颗石子, 同样是先手胜

假设两堆石子, 数量为`2 2`, 无论怎么取先手都无法获胜

设 `k = A1 ^ A2 ^ A3 ^ ... ^ An `
- 如果 `k == 0`, 根据异或的性质可以知道，**二进制表示**的**k**的每一位上的 **1** 都可以找到一个数与之抵消, 先手取的数后手可以取相应的数抵消使**k**重新变为**0**, 这种情况下后手必胜
- 如果 `k != 0`, 找到一个可以使**k**变为**0**的数取走, 使对手面对的局面变为第一种, 那么就可以保证先手必胜

## 代码
```c++
#include <iostream>
using namespace std;

int n;

int main(){
    int k=0, x;
    scanf("%d", &n);
    while( n-- ){
        scanf("%d", &x);
        k ^= x;
    }
    if( k ) puts("Yes");
    else puts("No");
    return 0;
}

```



-------------------------------------
# Nim Game Ⅱ
## 题目描述
有一个 `n` 级台阶的楼梯，每级台阶上都有若干个石子，其中第 `i` 级台阶上有 `Ai` 个石子(i≥1)。

两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。

已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。

如果两人都采用最优策略，先手是否必胜。

## 分析
由于两人都采取**最优策略**, 因此不考虑失误的情况, 则情况只分为 **初始状态先手必胜** 和 **初始状态先手必败** 两种

石子最后会放到地面上, 可以视为最后放到第`0`级台阶上

设 `k = A1 ^ A3 ^ ... ^ A(2j+1)  ( 2j+1 <= n ) `

假设现在要选择第`i (i>0)`级台阶拿石子：
- 如果`i`为偶数, 不管拿多少石子到第`i-1`级台阶, 对手都可以从第`i-1`级台阶拿同样多的石子放到`i-2`级台阶, 奇数阶的石子异或和不变
- 如果`i`为奇数
    - 如果`k == 0`, 不论拿多少石子到第`i-1`级台阶, 对手都可以从偶数级或奇数级台阶拿石子使得`k`值恢复为**0**, 即使得奇数阶的石子异或和仍为**0**
    - 如果`k != 0`, 一定存在一种拿法使得`k`值变为**0**, 把`k == 0`的情况留给对手

## 代码
```c++
#include <iostream>
using namespace std;

int n;

int main(){
    int k=0, x;
    scanf("%d", &n);
    for( int i=1; i<=n; i++ ){
        scanf("%d", &x);
        if( i&1 ) k ^= x;
    }
    if( k ) puts("Yes");
    else puts("No");
    return 0;
}
```
